<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>C++ By Example</title>
<!-- 2018-03-21 Wed 00:05 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Sebastian Stabinger" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, initial-scale=1"><style media="screen" type="text/css">html,pre{color:#657b83}article,aside,details,figcaption,figure,footer,header,hgroup,img,nav,section,summary{display:block}body,img{margin:0 auto}body,pre{border:1pt solid #93a1a1;padding:1em;background-color:#fdf6e3}body,pre,pre code{background-color:#fdf6e3}code,html,tr:nth-child(even){background-color:#eee8d5}@font-face{font-family:Hack;src:url(http://cdn.jsdelivr.net/font-hack/2.018/fonts/eot/hack-regular-webfont.eot?v=2.018);src:url(http://cdn.jsdelivr.net/font-hack/2.018/fonts/eot/hack-regular-webfont.eot?#iefix&v=2.018) format('embedded-opentype'),url(http://cdn.jsdelivr.net/font-hack/2.018/fonts/woff2/hack-regular-webfont.woff2?v=2.018) format('woff2'),url(http://cdn.jsdelivr.net/font-hack/2.018/fonts/woff/hack-regular-webfont.woff?v=2.018) format('woff'),url(http://cdn.jsdelivr.net/font-hack/2.018/fonts/web-ttf/hack-regular-webfont.ttf?v=2.018) format('truetype'),url(http://cdn.jsdelivr.net/font-hack/2.018/fonts/svg/hack-regular-webfont.svg?v=2.018#hackregular) format('svg');font-weight:400;font-style:normal}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:300;src:local('Roboto Slab Light'),local('RobotoSlab-Light'),url(http://fonts.gstatic.com/s/robotoslab/v6/dazS1PrQQuCxC3iOAJFEJavyPXdneeGd26m9EmFSSWg.woff2) format('woff2');unicode-range:U+0100-024F,U+1E00-1EFF,U+20A0-20AB,U+20AD-20CF,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:300;src:local('Roboto Slab Light'),local('RobotoSlab-Light'),url(http://fonts.gstatic.com/s/robotoslab/v6/dazS1PrQQuCxC3iOAJFEJUo2lTMeWA_kmIyWrkNCwPc.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2212,U+2215,U+E0FF,U+EFFD,U+F000}@font-face{font-family:'Roboto Condensed';font-style:normal;font-weight:300;src:local('Roboto Condensed Light'),local('RobotoCondensed-Light'),url(http://fonts.gstatic.com/s/robotocondensed/v13/b9QBgL0iMZfDSpmcXcE8nPVFL0ofnRu5Y2lP-UpEUGU.woff2) format('woff2');unicode-range:U+0100-024F,U+1E00-1EFF,U+20A0-20AB,U+20AD-20CF,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto Condensed';font-style:normal;font-weight:300;src:local('Roboto Condensed Light'),local('RobotoCondensed-Light'),url(http://fonts.gstatic.com/s/robotocondensed/v13/b9QBgL0iMZfDSpmcXcE8nBBQ_Gf4FfI8J4SYljBAylk.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2212,U+2215,U+E0FF,U+EFFD,U+F000}audio,canvas,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden]{display:none}html{-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;margin:1em}a:focus{outline:dotted thin}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,h1,h2,strong{font-weight:700}dfn{font-style:italic}mark{background:#ff0;color:#000}code,kbd,pre,samp{font-family:monospace,serif;font-size:1em}pre{white-space:pre-wrap;word-wrap:break-word;box-shadow:5pt 5pt 8pt #eee8d5;text-align:left}q{quotes:"\201C" "\201D" "\2018" "\2019"}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0;max-width:600px}svg:not(:root){overflow:hidden}figure{margin:0}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}button,input{line-height:normal}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],input[disabled]{cursor:default}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=search]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0;border:hidden #93a1a1;margin-left:auto;margin-right:auto}body,html{font-family:'Roboto Slab',serif}code,pre{font-family:Hack,monospace}h1,h2,h3,h4,h5,h6{font-family:'Roboto Condensed',sans-serif}h3{font-weight:300}h4,h5,h6{font-weight:100}body{max-width:23cm;text-align:justify}code{padding:2px}a{color:#268bd2}a:hover,a:visited{color:#cb4b16}h1{color:#dc322f;text-align:center;font-size:2.8em}h2,h3,h4,h5,h6{color:#6c71c4}h2{font-size:2.4em}h3{font-size:2em}h4{font-size:1.6em}h5{font-size:1.3em}h6{font-size:1.15em}colgroup{border:1px solid #93a1a1}span.todo.TODO{background-color:#dc322f}span.done.nilDONE,span.todo.DONE{background-color:#859900}.tag{background-color:#eee8d5;color:#d33682;padding:0 .2em;-webkit-border-radius:.35em;-moz-border-radius:.35em;border-radius:.35em}.done,.next,.todo{color:#fdf6e3;background-color:#dc322f;padding:0 .2em}.TODO{-webkit-border-radius:.2em;-moz-border-radius:.2em;border-radius:.2em;background-color:#2aa198}.ACTIVE,.DONE,.NEXT{-webkit-border-radius:.2em;-moz-border-radius:.2em}.ACTIVE,.NEXT{border-radius:.2em;background-color:#268bd2}.DONE{border-radius:.2em;background-color:#859900}.HOLD,.NOTE,.WAITING{-webkit-border-radius:.2em;-moz-border-radius:.2em}.WAITING{border-radius:.2em;background-color:#cb4b16}.HOLD,.NOTE{border-radius:.2em;background-color:#d33682}.CANCELLED{-webkit-border-radius:.2em;-moz-border-radius:.2em;border-radius:.2em;background-color:#859900}pre span.org-builtin{color:#859900}pre span.org-string{color:#2aa198}pre span.org-keyword{color:#859900}pre span.org-variable-name{color:#268bd2}pre span.org-function-name{color:#6c71c4}pre span.org-type{color:#b58900}pre span.org-comment,pre span.org-comment-delimiter{color:#93a1a1}pre span.org-preprocessor{color:#dc322f}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">C++ By Example</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Einführung</a>
<ul>
<li><a href="#sec-1-1">1.1. Geschichte von C++</a></li>
<li><a href="#sec-1-2">1.2. Verwandschaft zu anderen Sprachen</a></li>
<li><a href="#sec-1-3">1.3. Warum C++</a></li>
</ul>
</li>
<li><a href="#sec-2">2. C vs C++</a>
<ul>
<li><a href="#sec-2-1">2.1. Funktionsüberladung</a></li>
<li><a href="#sec-2-2">2.2. Verwendung komplexer Zahle</a></li>
<li><a href="#sec-2-3">2.3. Typinferenz</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Hello World</a>
<ul>
<li><a href="#sec-3-1">3.1. C</a></li>
<li><a href="#sec-3-2">3.2. C++</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Datentypen</a>
<ul>
<li><a href="#sec-4-1">4.1. Ganzzahlen</a></li>
<li><a href="#sec-4-2">4.2. Fließkommazahlen</a></li>
<li><a href="#sec-4-3">4.3. Welche Datentypen sollte man verwenden?</a></li>
<li><a href="#sec-4-4">4.4. Boolsche Werte</a></li>
<li><a href="#sec-4-5">4.5. <code>auto</code></a></li>
<li><a href="#sec-4-6">4.6. Strings</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Ein-/Ausgabe</a>
<ul>
<li><a href="#sec-5-1">5.1. Ausgabe</a></li>
<li><a href="#sec-5-2">5.2. Eingabe</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Einführung</h2>
<div class="outline-text-2" id="text-1">
<p>
Dieses Skriptum soll es Ihnen erleichtern dem Stoff der
Lehrveranstaltung <i>Programmieren 3</i> zu folgen. Es ist umfangreicher
als die Folien und enthält zudem mehr Beispiele als in der
Lehrveranstaltung selbst besprochen werden können. Zudem enthält das
Skriptum auch Teile die Ihnen bereits aus Ihren Lehrveranstaltungen zu
C bekannt sein sollten und für die in <i>Programmieren 3</i> keine Zeit zur
Wiederholung ist.
</p>

<p>
Ich bin der Auffassung, dass gerade Programmieranfänger von einer
großen Anzahl an präsentierten Beispielen profitieren. Ich versuche
daher zu jedem theoretisch eingeführten Konzept eine Vielzahl an
ausführlich kommentierten Beispielen zu präsentieren.
</p>

<p>
Bedenken Sie bitte, dass dieses Skriptum kein Buch zum Thema C++
ersetzen kann. Aus zeitlichen Gründen muss ich viele Themenbereiche
entweder komplett auslassen, oder bin nur dazu in der Lage sie kurz
anzuschneiden. Sollten Sie Interesse an der Programmierung in C++
haben ist es sinnvoll sich weiterführende Literatur zum Thema zu
besorgen.
</p>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Geschichte von C++</h3>
<div class="outline-text-3" id="text-1-1">
<dl class="org-dl">
<dt> 1979 </dt><dd>Bjarne Stroustrup beginnt mit der Arbeit an "C with classes"
(C mit Klassen). Es war als eine Erweiterung zu C gedacht welche
die objektorientierte Programmierung in C erleichtert.
</dd>
<dt> 1983 </dt><dd>Umbenennung in C++
</dd>
<dt> 1998 </dt><dd>Erster ISO C++ Standard. C++ ist eine der wenigen Sprachen
die offiziell standardisiert ist. Andere Beispiele sind C und
Fortran. Es gibt keinen offiziellen Compiler für C++ (so wie es
z.B. eine offizielle Version von Matlab, Java oder Python gibt).
Daher war es wichtig einen Standard zu schaffen an den sich
unterschiedliche Compiler halten können.
</dd>
<dt> 2011 </dt><dd>Ein neuer ISO Standard wird veröffentlicht, der recht viel
an der Sprache ändert. <b>Der C++11 Standard ist der Standard den
wir in dieser Lehrveranstaltung verwenden werden.</b>
</dd>
<dt> 2014 </dt><dd>ISO C++ 14. Kleine Änderungen am Standard. Betreffen uns in
dieser Lehrveranstaltung nicht.
</dd>
<dt> 2017 </dt><dd>ISO C++17. Größere Änderungen, aber nichts was uns in dieser
Lehrveranstaltung berührt.
</dd>
</dl>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Verwandschaft zu anderen Sprachen</h3>
<div class="outline-text-3" id="text-1-2">
<p>
C++ ist ursprünglich als eine Erweiterung zu C entwickelt worden um
die objektorientierte Programmierung zu erleichtern. Es ist daher
immer noch fast jeder C Code auch gültiger C++ Code. Über die Jahre
hat sich die Sprache C++ aber stark weiterenwickelt während die
Sprache C relativ unverändert geblieben ist. Heute ist es so, dass C
Code zwar prinzipiell auch gültiger C++ Code ist (mit kleinen
Ausnahmen), aber schön geschriebener C++ Code hat nicht mehr viel mit
C gemeinsam. Wenn C++ Code also aussieht wie C Code, dann ist er in
der Regel schlecht geschrieben.
</p>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Warum C++</h3>
<div class="outline-text-3" id="text-1-3">
<dl class="org-dl">
<dt> Sehr schnell, geringer Speicherverbrauch </dt><dd>C++ basiert auf dem
Konzept, dass ein Programm keine Dinge tut die man nicht explizit
angibt. Dadurch sind Programme die in C++ geschrieben sind
generell relativ schnell und verbrauchen wenig Arbeitsspeicher.
</dd>
<dt> Hardwarenahe Programmierung </dt><dd>C++ eignet sich genauso wie C für
sehr hardwarenahe Programmierung. Man kann z.B. sehr genau
bestimmen was bei der Ausführung in der CPU passiert, etc.
</dd>
<dt> Verwenden von C-Bibliotheken </dt><dd>Durch die historische Nähe von C++
zu C lassen sich C-Bibliotheken genauso einfach verwenden wie in
C selbst. Das ist von Vorteil, da sehr viele C-Bibliotheken
existieren. Speziell wenn man mit Hardware interagieren will,
existiert üblicherweise eine C-Bibliotheken für diesen Zweck vom
Hersteller.
</dd>
<dt> Flexibel </dt><dd>C++ ist vermutlich die flexibelste Sprache hinsichtlich
des Einsatzgebietes. Man kann vom Mikroprozessor, über
PCs/Konsolen, bis hin zu High Performance Computing auf riesigen
Clustern mit zehntausenden CPUs alles programmieren. Und C++ wird
in all diesen Bereichen auch tagtäglich eingesetzt.
</dd>
<dt> Hohes Maß an Abstraktion </dt><dd>Im Gegensatz zu C ist ein hohes Maß an
Abstraktion möglich (OOP, Templates, Meta Template Programming,
&#x2026;). Wir werden auf diese Dinge noch im Verlauf des Semesters
genauer eingehen. Dieses höhere Maß an Abstraktion macht zwar die
Sprache selbst komplexer (da es mehr Konzepte gibt die man lernen
und verstehen muss), aber das Programmieren selbst wird dadurch
letztlich einfacher wenn man die Konzepte verstanden hat.
</dd>
<dt> Grössere Standardbibliothek </dt><dd>Im Gegensatz zu C inkludiert C++ eine
wesentlich größere Standardbibliothek. Wir werden im Laufe des
Semesters einige nützliche Bereiche der Standardbibliothek kennen
lernen. Im Vergleich zu den Standardbibliotheken von Sprachen wie
Java, Python, C#, &#x2026; ist sie aber immer noch relativ klein.
</dd>
<dt> Lange erprobt </dt><dd>C++ existiert seit 35 Jahren und hat sich im
industriellen Einsatz bewährt. Die Sprache hat ihre Probleme,
aber man hat gelernt damit umzugehen. Es ist daher anzunehmen,
dass die Sprache auch in Zukunft weiterhin ihren Platz haben
wird. Im <a href="https://www.tiobe.com/tiobe-index/">TIOBE Index</a> welcher Sprachen nach ihrer popularität
bewertet ist C++ z.B. seit Jahrzehnten in den Top-5 (C ist seit
Jahrzehnten abwechselnd auf Platz 1 oder 2)
</dd>
<dt> Sehr große Code Base </dt><dd>Sehr viele Programme sind in C++
geschrieben. Zum Beispiel sind faktisch alle Anwendungen (Office,
Webbrowser, &#x2026;) in C++ geschrieben. Spiele auf PC oder Konsolen
werden heutzutage auch fast durchgehend in C++ entwickelt. Es
gibt also sehr viel C++ Code der gewartet und weiter entwickelt
werden muss.
</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> C vs C++</h2>
<div class="outline-text-2" id="text-2">
<p>
Ich will Ihnen hier einen kleinen Vorgeschmack geben, wie einem C++
das Leben gegenüber C leichter machen kann. Dieses Kapitel ist als
Vorschau gedacht und soll Ihnen C++ schmackhaft machen. Sie müssen
noch nicht verstehen, was hier im Detail passiert.
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Funktionsüberladung</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Angenommen Sie wollen eine Funktion schreiben mit der man das Quardat
einer Zahl bestimmen kann und Sie wollen diese Funktion für <code>int</code>
(Ganzzahlen) als auch für <code>double</code> (Fließkommazahlen) implementieren.
</p>
</div>
<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> In C</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
In C ist es nicht erlaubt zwei Funktionen mit dem gleichen Namen zu
definieren, selbst wenn die Datentypen der Parameter unterschiedlich
sind oder sie unterschiedliche Anzahl an Parametern haben. Wir müssen
also für unsere Funktion zwei verschiedene Namen wählen und bei der
Verwendung selbst daran denken die richtige Version zu verwenden.
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="org-type">int</span> <span class="org-function-name">quadriere_int</span>(<span class="org-type">int</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> a * a; }
<span class="org-type">double</span> <span class="org-function-name">quadriere_double</span>(<span class="org-type">double</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> a * a; }

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = 2;
  <span class="org-type">double</span> <span class="org-variable-name">d</span> = 2.0;

  <span class="org-type">int</span> <span class="org-variable-name">qi</span> = quadriere_int(i);
  <span class="org-type">double</span> <span class="org-variable-name">qd</span> = quadriere_double(d);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> In C++</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
In C++ können wir mehreren Funktionen den gleichen Namen geben, so
lange die Datentypen der Parameter unterschiedlich sind. Der C++
Compiler wählt dann anhand der Datentypen automatisch die richtige
Version aus. Man bezeichnet das als <b><a href="https://msdn.microsoft.com/de-de/library/5dhe1hce.aspx">Funktionsüberladung</a></b> (function
overloading) . In unserem Fall können wir also für die Quadrierfunktion
für <code>int</code> und für <code>double</code> den gleichen Namen wählen und der Compiler
verwendet automatisch die richtige Version.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">int</span> <span class="org-function-name">quadriere</span>(<span class="org-type">int</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> a * a; }
<span class="org-type">double</span> <span class="org-function-name">quadriere</span>(<span class="org-type">double</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> a * a; }

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = 2;
  <span class="org-type">double</span> <span class="org-variable-name">d</span> = 2.0;

  <span class="org-type">int</span> <span class="org-variable-name">qi</span> = quadriere(i);
  <span class="org-type">double</span> <span class="org-variable-name">qd</span> = quadriere(d);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> In C++ mit Templates</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
Wir haben aber immer noch das Problem, dass wir für jeden Datentyp
eine eigene Version unserer Quadrierfunktion implementieren müssen
obwohl ja unabhängig vom Typ immer das gleiche passiert (es wird
einfach der übergebene Parameter mit sich selbst multipliziert). C++
ermöglicht es mittels sogenannter Templates, Funktionen zu schreiben
welche automatisch für alle Typen funktionieren welche z.B. die
Multiplikation unterstüzen.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-type">T</span> <span class="org-function-name">quadriere</span>(<span class="org-type">T</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> a * a; }

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = 2;
  <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">ui</span> = 2;
  <span class="org-type">short</span> <span class="org-variable-name">d</span> = 2;
  <span class="org-type">double</span> <span class="org-variable-name">d</span> = 2.0;

  <span class="org-type">int</span> <span class="org-variable-name">qi</span> = quadriere(i);
  <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">qui</span> = quadriere(ui);
  <span class="org-type">short</span> <span class="org-variable-name">qs</span> = quadriere(s);
  <span class="org-type">double</span> <span class="org-variable-name">qd</span> = quadriere(d);
}
</pre>
</div>
<p>
Das <code>T</code> dient hier als ein Platzhalter für beliebige Datentypen.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Verwendung komplexer Zahle</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Angenommen wir wollen das Ergebnis dieser Formel berechnen und müssen
daher mit komplexen Zahen rechnen: $$d=\frac{(1.3+5i)+5}{(3.4+1i)^2}$$
Sowohl C als auch C++ bieten über ihre Standardbibliothek das Rechnen
mit komplexen Zahlen an. <b>Achtung:</b> Die folgenden Beispiele verwenden
nicht die Implementierungen wie sie von C und C++ zur Verfügung
gestellt werden. Die Beispiele verdeutlichen nur, wie eine
Implementierung aussehen könnte.
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> In C</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Da C nur sehr wenige Möglichkeiten zur Abstraktion bietet müssen alle
Operationen über Funktionen realisiert werden. Es ist in C z.B. nicht
möglich eigenes Verhalten für <code>+</code> zu implementieren. Wir müssen daher
zum Addieren von zwei komplexen Zahlen die Funktion <code>complex_add</code>
verwenden, etc. Das macht den Code sehr unleserlich.
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="org-keyword">struct</span> <span class="org-type">complex</span> <span class="org-variable-name">d</span> =
    complex_div(complex_add(create_complex(1.3, 5), create_complex(5, 0)),
                complex_pow(create_complex(3.4, 1.0), 2));
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> In C++</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
C++ erlaubt die Implementierung von eigenen Versionen von <code>+</code>, <code>*</code>,
&#x2026; Man bezeichnet dies als <a href="https://de.wikipedia.org/wiki/%25C3%259Cberladen#Operator%C3%BCberladung">Operatorüberladung</a> (operator overloading).
Dadurch wir Code häufig leichter lesbar.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">complex</span> <span class="org-variable-name">d</span> = (complex(1.3, 5.0) + 5.0) / complex(3.4, 1.0) ^ 2.0;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Typinferenz</h3>
<div class="outline-text-3" id="text-2-3">
<p>
In C müssen wir den Datentyp einer Variable angeben, auch wenn der
Compiler eigentlich selbst herausfinden könnte welchen Datentyp die
Variable haben muss. Angenommen wir haben folgende Funktionen gegeben:
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">some_long_name</span> <span class="org-function-name">get_struct</span>();
<span class="org-type">void</span> <span class="org-function-name">do_something_with_struct</span>(<span class="org-keyword">struct</span> <span class="org-type">some_long_name</span> <span class="org-variable-name">a</span>);
</pre>
</div>
<p>
Wir wollen nun mittels <code>get_struct</code> eine Variable befüllen und diese
dann mittels <code>do_something_with_struct</code> weiterverarbeiten.
</p>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> Verwendung in C</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
In C müssen wir den Datentyp der Variable <code>mystruct</code> explizit angeben,
obwohl der Compiler ja selbst herausfinden könnte welchen Datentyp
<code>get_struct</code> zurück gibt und den selben Typ für die Variable verwenden
könnte.
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="org-keyword">struct</span> <span class="org-type">some_long_name</span> <span class="org-variable-name">mystruct</span> = get_struct();
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
do_something_with_struct(mystruct);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> Verwendung in C++(11)</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
Seit C++11 unterstützt C++ eine einfache Form der <a href="https://de.wikipedia.org/wiki/Typinferenz">Typinferenz</a>. Dadurch
muss der Datentyp einer Variable nicht angegeben werden, falls der
Compiler den Datentyp selbst bestimmen kann. Um den Compiler zu
veranlassen den Datentyp selbst zu bestimmen, wird statt des Datentyps
das Schlüsselwort <code>auto</code> verwendet.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">auto</span> <span class="org-variable-name">mystruct</span> = get_struct();
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
do_something_with_struct(mystruct);
</pre>
</div>
<p>
<code>auto</code> findet den Typ einer Variable also automatisch.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">auto</span> <span class="org-variable-name">i</span> = 42;   <span class="org-comment-delimiter">// </span><span class="org-comment">i ist vom Typ int</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">d</span> = 23.4; <span class="org-comment-delimiter">// </span><span class="org-comment">d ist vom Typ double</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">c</span> = <span class="org-string">'A'</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">c ist vom Typ char</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Hello World</h2>
<div class="outline-text-2" id="text-3">
<p>
Heute ist es üblich, als erstes Beispiel einer Programmiersprache das
sogenannte "<a href="https://de.wikipedia.org/wiki/Hallo-Welt-Programm">Hello World</a>" Programm zu implementieren. Es handelt sich
dabei um ein Programm welches einfach den Text "Hello World" auf dem
Bildschirm ausgibt. Begonnen hat diese Tradition im Buch <a href="https://de.wikipedia.org/wiki/The_C_Programming_Language">The C
Programming Language</a> (DAS Standardwerk zu C) von Kernighan und
Ritchie. Es folgt ein Vergleich dieses Programms in C (welches Sie
bereits kennen sollten) und C++.
</p>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> C</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    printf(<span class="org-string">"Hello World\n"</span>);
}
</pre>
</div>
<p>
Die Headerdatei <code>stdio.h</code> wird eingebunden um <code>printf</code> verwenden zu
können. Die Funktion <code>main</code> ist die Funktion die bei Ausführung eines
Programms als erstes aufgerufen wird. Die Funktion <code>printf</code> ist der
Standardweg um Text in C auf dem Bildschirm auszugeben.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> C++</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Hello World"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
}
</pre>
</div>
<p>
Hier wird der Header für <code>iostream</code> eingebunden um <code>std::cout</code>
verwenden zu können. Bei C++ ist es üblich die Dateierweiterung <code>.h</code>
bei Headerdateien wegzulassen. In C++ ist <code>std::cout</code> der Standardweg
um Text auf dem Bildschirm auszugeben. Der Bezeichner <code>std::endl</code>
bewirkt das gleiche wie <code>\n</code> in C (ein Zeilenumbruch wird eingefügt).
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Datentypen</h2>
<div class="outline-text-2" id="text-4">
<p>
Alle Datentypen die in C verfügbar sind können und werden auch in C++
verwendet.
</p>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Ganzzahlen</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Ganzzahlen werden verwendet um ganze Zahlen (ohne Kommastellen) zu
speichern. Die unterschiedlichen Datentypen für Ganzzahlen
unterscheiden sich hinsichtlich der Wertebereiche welche in ihnen
gespeichert werden können und wie viel Speicher eine einzelne Zahl
belegt.
</p>

<p>
Leider ist die Größe dieser Datentypen in C nicht standardisiert (es
ist nur die minimale Größe spezifiziert). Sollte man garantierte
Größen benötigen kann man (seit C99) den Header <code>stdint.h</code> verwenden
(<a href="http://openbook.rheinwerk-verlag.de/c_von_a_bis_z/030_c_anhang_b_017.htm">weitere Info</a>). Auf einem aktuellen PC mit 64 Bit Architektur sind
folgende Größen üblich. Auf Mikroprozessoren und Embedded Devices
können die Größen stark von dieser Tabelle abweichen.
</p>

<table cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Bezeichner</th>
<th scope="col" class="left">Übliche Größe auf PC</th>
<th scope="col" class="left">Üblicher Wertebereich auf PC</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>char</code></td>
<td class="left">8 Bit</td>
<td class="left">-128 &#x2026; 127</td>
</tr>

<tr>
<td class="left"><code>unsigned char</code></td>
<td class="left">8 Bit</td>
<td class="left">0 &#x2026; 255</td>
</tr>

<tr>
<td class="left"><code>short</code></td>
<td class="left">16 Bit</td>
<td class="left">-32768 &#x2026; 32767</td>
</tr>

<tr>
<td class="left"><code>unsiged short</code></td>
<td class="left">16 Bit</td>
<td class="left">0 &#x2026; 65536</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left">32 Bit</td>
<td class="left">-2147483648 &#x2026; 2147483647</td>
</tr>

<tr>
<td class="left"><code>unsigned int</code></td>
<td class="left">32 Bit</td>
<td class="left">0 &#x2026; 4294967296</td>
</tr>

<tr>
<td class="left"><code>long</code></td>
<td class="left">32/64 Bit</td>
<td class="left">-9223372036854775808 &#x2026; 9223372036854775807</td>
</tr>

<tr>
<td class="left"><code>unsigned long</code></td>
<td class="left">32/64 Bit</td>
<td class="left">0 &#x2026; 18446744073709551616</td>
</tr>

<tr>
<td class="left"><code>long long</code></td>
<td class="left">64 Bit</td>
<td class="left">-9223372036854775808 &#x2026; 9223372036854775807</td>
</tr>

<tr>
<td class="left"><code>unsigned long long</code></td>
<td class="left">64 Bit</td>
<td class="left">0 &#x2026; 18446744073709551616</td>
</tr>
</tbody>
</table>

<p>
Ganzzahlen mit mehr als 64 Bit werden üblicherweise nicht direkt von C
unterstützt (einige Compiler unterstützen noch 128 Bit Ganzzahlen).
Falls man größere Zahlen benötigt muss eine externe Bibliothek, z.B.
<a href="https://gmplib.org/">GMP</a> , verwendet werden. Mit dieser Bibliothek sind beliebig große
Ganzzahlen möglich.
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Fließkommazahlen</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Fließkommazahlen sind eine Möglichkeit Zahlen mit Nachkommastellen in
einem Computer darzustellen. Die Anzahl der Nachkommastellen ist nicht
fix vorgegeben. Daher der Name <b>Fließ</b>-kommazahlen. C kennt die
folgenden Datentypen für Fließkommazahlen.
</p>

<table cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Bezeichner</th>
<th scope="col" class="left">Größe</th>
<th scope="col" class="left">Wertebereich</th>
<th scope="col" class="left">Genauigkeit</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>float</code></td>
<td class="left">32 Bit</td>
<td class="left">\(\pm3.4*10^{38}\)</td>
<td class="left">ca. 7 Stellen</td>
</tr>

<tr>
<td class="left"><code>double</code></td>
<td class="left">64 Bit</td>
<td class="left">\(\pm2.3*10^{308}\)</td>
<td class="left">ca. 16 Stellen</td>
</tr>

<tr>
<td class="left"><code>long double</code></td>
<td class="left">128 Bit</td>
<td class="left">\(\pm3.4*10^{4932}\)</td>
<td class="left">ca. 19 Stellen</td>
</tr>
</tbody>
</table>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">auto</span> <span class="org-variable-name">pi</span> = 3.14159265358979323846;
<span class="org-keyword">auto</span> <span class="org-variable-name">tau</span> = 2 * pi;
<span class="org-keyword">auto</span> <span class="org-variable-name">ganz</span> = 3.0; <span class="org-comment-delimiter">// </span><span class="org-comment">Auch 3.0 ist eine Kommazahl (mit .0000 als Kommastellen)</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">ganz2</span> = 4.; <span class="org-comment-delimiter">// </span><span class="org-comment">Ein . ist ausreichend um eine Flie&#223;kommazahl zu erzeugen</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">expo</span> = 3e3; <span class="org-comment-delimiter">// </span><span class="org-comment">Exponentialschreibweise. Entspricht 3*10^3</span>
<span class="org-type">double</span> <span class="org-variable-name">kein_integer</span> = 23; <span class="org-comment-delimiter">// </span><span class="org-comment">Wird automatisch in 23.0 umgewandelt</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Welche Datentypen sollte man verwenden?</h3>
<div class="outline-text-3" id="text-4-3">
<p>
<b>Generell faktisch immer <code>int</code> und <code>double</code></b> 
</p>

<p>
C und C++ unterstützen sehr viele unterschiedliche Datentypen für
Zahlen, aber nur wenige sind ohne spezielle Gründe sinnvoll. Falls Sie
keine SEHR guten Gründe haben, sollten Sie generell <code>int</code> und <code>double</code>
verwenden. Gute Gründe sind fast ausschließlich die Interaktion mit
Hardware welche bestimmte Datentypen benötigen.
</p>

<p>
Das Rechnen mit <code>short</code> und <code>float</code> ist auf PCs <b>nicht generell
schneller</b> als das Rechnen mit <code>int</code> und <code>double</code> und häufig sogar
langsamer.
</p>

<p>
Der Datentyp <code>char</code> stellt eine Ausnahme dar da er zum Speichern von
Zeichen verwendet wird.
</p>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Boolsche Werte</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Wie auch in C werden Wahrheitswerte (true/false) in C++ durch
Ganzzahlen dargestellt. Die Zahl <code>0</code> repräsentiert <code>false</code> und alle
anderen Zahlen (positiv wie auch negativ) repräsentieren <code>true</code>.
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-keyword">if</span>(0) printf(<span class="org-string">"true"</span>); <span class="org-keyword">else</span> printf(<span class="org-string">"false"</span>);     <span class="org-comment-delimiter">// </span><span class="org-comment">false</span>
<span class="org-keyword">if</span>(-0) printf(<span class="org-string">"true"</span>); <span class="org-keyword">else</span> printf(<span class="org-string">"false"</span>);    <span class="org-comment-delimiter">// </span><span class="org-comment">false</span>
<span class="org-keyword">if</span>(23-23) printf(<span class="org-string">"true"</span>); <span class="org-keyword">else</span> printf(<span class="org-string">"false"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">false</span>
<span class="org-keyword">if</span>(42) printf(<span class="org-string">"true"</span>); <span class="org-keyword">else</span> printf(<span class="org-string">"false"</span>);    <span class="org-comment-delimiter">// </span><span class="org-comment">true</span>
<span class="org-keyword">if</span>(-255) printf(<span class="org-string">"true"</span>); <span class="org-keyword">else</span> printf(<span class="org-string">"false"</span>);  <span class="org-comment-delimiter">// </span><span class="org-comment">true</span>

<span class="org-type">int</span> <span class="org-variable-name">a</span> = 0;
<span class="org-type">int</span> <span class="org-variable-name">b</span> = 47;
<span class="org-keyword">if</span>(a) printf(<span class="org-string">"true"</span>); <span class="org-keyword">else</span> printf(<span class="org-string">"false"</span>);  <span class="org-comment-delimiter">// </span><span class="org-comment">false</span>
<span class="org-keyword">if</span>(b) printf(<span class="org-string">"true"</span>); <span class="org-keyword">else</span> printf(<span class="org-string">"false"</span>);  <span class="org-comment-delimiter">// </span><span class="org-comment">true</span>
</pre>
</div>

<p>
In C++ gibt es allerdings einen eigenen Datetyp zur Speicherung von
Wahrheitswerten namens <code>bool</code>. Intern wird immer noch eine Ganzzahl
gespeichert (die Größe ist nicht spezifiziert, aber häufig 1 Byte),
aber die Verwendung von <code>bool</code> hat einige Vorteile:
</p>

<ol class="org-ol">
<li>Die Verwendung von <code>bool</code> macht klar, dass die Variable, der
Parameter, der Rückgabewert nur Wahrheitswerte berücksichtigt. Bei
Verwendung von z.B. <code>int</code> ist das häufig nicht offensichtlich.
</li>
<li>Es gibt die Bezeichner <code>true</code> und <code>false</code> mit denen verglichen
werden kann und die als Rückgabewert verwendet werden können, was
den Code ebenfalls lesbarer macht.
</li>
<li>Der Datentyp <code>bool</code> garantiert, dass intern nur <code>0</code> oder <code>1</code>
gespeichert wird, selbst wenn andere Zahlen zugewiesen werden (was
gültig ist)
</li>
</ol>

<p>
In C ist etwas sehr ähnliches durch das Einbinden der Headerdatei
<code>stdbool.h</code> verfügbar (<a href="http://openbook.rheinwerk-verlag.de/c_von_a_bis_z/005_c_basisdatentypen_015.htm">Info</a>). In C++ ist <code>bool</code> allerdings fixer
Bestandteil der Sprache selbst.
</p>
</div>

<div id="outline-container-sec-4-4-1" class="outline-4">
<h4 id="sec-4-4-1"><span class="section-number-4">4.4.1</span> Beispiel 1</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
Wir sehen uns die Verwendung von <code>bool</code> als Rückgabewert einer
Funktion an die zurück gibt ob ein Integer gerade ist oder nicht.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">bool</span> <span class="org-function-name">ist_gerade</span>(<span class="org-type">int</span> <span class="org-variable-name">zahl</span>) {
  <span class="org-keyword">if</span> (zahl % 2 == 0)
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  <span class="org-keyword">else</span>
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">a</span> = 23;
  <span class="org-keyword">if</span> (ist_gerade(a)) <span class="org-comment-delimiter">// </span><span class="org-comment">bool kann direkt als Bedingung verwendet werden</span>
    cout &lt;&lt; a &lt;&lt; <span class="org-string">" ist gerade"</span> &lt;&lt; endl;
  <span class="org-keyword">else</span>
    cout &lt;&lt; a &lt;&lt; <span class="org-string">" ist nicht gerade"</span> &lt;&lt; endl;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">23 ist nicht gerade</span>

  <span class="org-type">int</span> <span class="org-variable-name">b</span> = 42;
  <span class="org-type">bool</span> <span class="org-variable-name">ist_b_gerade</span> =
      ist_gerade(b); <span class="org-comment-delimiter">// </span><span class="org-comment">Wir k&#246;nnen bool in einer Variable speichern</span>
  <span class="org-keyword">if</span> (b == <span class="org-constant">true</span>)     <span class="org-comment-delimiter">// </span><span class="org-comment">Wir k&#246;nnen explizit mit == vergleichen</span>
    cout &lt;&lt; b &lt;&lt; <span class="org-string">" ist gerade"</span> &lt;&lt; endl;
  <span class="org-keyword">else</span>
    cout &lt;&lt; b &lt;&lt; <span class="org-string">" ist nicht gerade"</span> &lt;&lt; endl;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">42 ist nicht gerade</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4-2" class="outline-4">
<h4 id="sec-4-4-2"><span class="section-number-4">4.4.2</span> Beispiel 2</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
Verwendung von <code>bool</code> als Parameter
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">void</span> <span class="org-function-name">print</span>(<span class="org-type">int</span> <span class="org-variable-name">zahl</span>, <span class="org-type">bool</span> <span class="org-variable-name">mit_text</span>) {
  <span class="org-keyword">if</span> (mit_text)
    cout &lt;&lt; <span class="org-string">"Zahl ist "</span> &lt;&lt; zahl &lt;&lt; endl;
  <span class="org-keyword">else</span>
    cout &lt;&lt; zahl &lt;&lt; endl;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = 42;
  print(i, <span class="org-constant">false</span>);
  print(i, <span class="org-constant">true</span>);
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">42</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Zahl ist 42</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4-3" class="outline-4">
<h4 id="sec-4-4-3"><span class="section-number-4">4.4.3</span> Beispiel 3</h4>
<div class="outline-text-4" id="text-4-4-3">
<p>
Wir sehen, dass eine Variable vom Typ <code>bool</code> mit <code>cout</code> als Zahl (<code>0</code>
oder <code>1</code>) ausgegeben wird und dass <code>bool</code> nur <code>0</code> oder <code>1</code> speichert,
selbst wenn eine andere Zahl zugewiesen wird.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">bool</span> <span class="org-variable-name">b1</span> = <span class="org-constant">true</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">b2</span> = <span class="org-constant">false</span>;

  cout &lt;&lt; <span class="org-string">"b1 = "</span> &lt;&lt; b1 &lt;&lt; <span class="org-string">", b2 = "</span> &lt;&lt; b2 &lt;&lt; endl;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">b1 = 1, b2 = 0</span>

  <span class="org-type">bool</span> <span class="org-variable-name">b3</span> = 500;
  cout &lt;&lt; <span class="org-string">"b3 = "</span> &lt;&lt; b3 &lt;&lt; endl;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">b3 = 1</span>

  cout &lt;&lt; <span class="org-string">"false = "</span> &lt;&lt; <span class="org-constant">false</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="org-string">"true = "</span> &lt;&lt; <span class="org-constant">true</span> &lt;&lt; endl;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">false = 0</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">true = 1</span>
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> <code>auto</code></h3>
<div class="outline-text-3" id="text-4-5">
<p>
Seit C++11 unterstützt C++ eine einfache Form der sogenannten
<a href="https://de.wikipedia.org/wiki/Typinferenz">Typinferenz</a>. Das bedeutet, dass wir den Datentyp einer Variable nicht
explizit angeben müssen, wenn der Compiler einen eindeutigen Typ
automatisch bestimmen kann. Der Compiler wird angewiesen den Datentyp
selbst zu bestimmen indem das Schlüsselwort <code>auto</code> statt des Datentyps
verwendet wird.
</p>

<p>
Das Schlüsselwort <code>auto</code> ändert nichts an der Tatsache, dass C++ den
Datentyp einer Variable bereits beim Compilieren eindeutig wissen muss
und dass sich dieser Datentyp während der Ausführung auch nicht ändern
kann!
</p>
</div>
<div id="outline-container-sec-4-5-1" class="outline-4">
<h4 id="sec-4-5-1"><span class="section-number-4">4.5.1</span> Vorteile</h4>
<div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li>Man kann sich teilweise das Schreiben langer Datentypen sparen. Dies
ist insbesondere hilfreich wenn man Templateparameter verwendet, da
die Typnamen dadurch sehr lange werden können. Templates und
Templateparameter werden später noch besprochen.
</li>
<li>Falls man den Datentyp an einer Stelle im Code ändert, ändern sich
automatisch alle davon betroffenen Variablen mit <code>auto</code> automatisch.
Ohne <code>auto</code> muss man möglicherweise an vielen Stellen im Code die
Datentypen manuell anpassen. Siehe späteres Beispiel.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5-2" class="outline-4">
<h4 id="sec-4-5-2"><span class="section-number-4">4.5.2</span> Nachteile</h4>
<div class="outline-text-4" id="text-4-5-2">
<ul class="org-ul">
<li>Der Code kann durch Verwendung vieler Variablen mit <code>auto</code>
unleserlich werden, da man nicht mehr auf einen Blick sieht was in
einer Variable gespeichert ist.
</li>
<li>Falls bei einer Variable klar ist, dass sie für das korrekte
Funktionieren des Codes einen bestimmten Datentyp haben muss (z.B.
<code>int</code> für einen Index eines Arrays) kann es ungünstig sein für diese
Variable <code>auto</code> zu verwenden, da es schwieriger wird Fehler zu
finden.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5-3" class="outline-4">
<h4 id="sec-4-5-3"><span class="section-number-4">4.5.3</span> Beispiel 1</h4>
<div class="outline-text-4" id="text-4-5-3">
<p>
Ein paar Beispiele von <code>auto</code> bei Zuweisungen
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">auto</span> <span class="org-variable-name">a</span> = 23;       <span class="org-comment-delimiter">// </span><span class="org-comment">a ist int</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">b</span> = 42.0;     <span class="org-comment-delimiter">// </span><span class="org-comment">b ist double</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">c</span> = <span class="org-string">'A'</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">c ist char</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">d</span> = 23 / 7;   <span class="org-comment-delimiter">// </span><span class="org-comment">d ist int</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">e</span> = 23 / 3.4; <span class="org-comment-delimiter">// </span><span class="org-comment">e ist double</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-5-4" class="outline-4">
<h4 id="sec-4-5-4"><span class="section-number-4">4.5.4</span> Beispiel 2</h4>
<div class="outline-text-4" id="text-4-5-4">
<p>
Hier ein Beispiel wie <code>auto</code> nicht verwendet werden kann:
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">auto</span> <span class="org-variable-name">i</span>;
i = 20;
<span class="org-comment-delimiter">// </span><span class="org-comment">Gibt einen Compilerfehler</span>
</pre>
</div>
<p>
Prinzipiell könnte der Compiler herausfinden, dass an <code>i</code> nach der
Deklaration ein <code>int</code> zugewiesen wird und deshalb <code>i</code> ein <code>int</code> sein
muss. Die Typinferenz in C++ ist aber nicht mächtig genug um das
aufzulösen. <code>auto</code> funktioniert nur, falls in der gleichen Zeile etwas
zugewiesen wird.
</p>
</div>
</div>
<div id="outline-container-sec-4-5-5" class="outline-4">
<h4 id="sec-4-5-5"><span class="section-number-4">4.5.5</span> Beispiel 3</h4>
<div class="outline-text-4" id="text-4-5-5">
<p>
Ein großer Vorteil von <code>auto</code> ist, dass sich definierte Typen
automatisch durch ein ganzes Programm durchziehen, ohne dass der
Datentyp an jeder Stelle geändert werden muss. Angenommen wir haben
den folgenden Code mit einem <code>int</code> als Anfangsdatentyp geschrieben:
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">start</span> = 23;
  <span class="org-type">int</span> <span class="org-variable-name">division</span> = start / 3;
  <span class="org-type">int</span> <span class="org-variable-name">addition</span> = division + 4;
  <span class="org-type">int</span> <span class="org-variable-name">ergebnis</span> = division * addition;
  cout &lt;&lt; <span class="org-string">"Ergebnis = "</span> &lt;&lt; ergebnis &lt;&lt; endl;
}
<span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Ergebnis = 77</span>
</pre>
</div>
<p>
Wollen wir nun alle Berechnungen mit <code>double</code> durchführen, so müssen
wir alle daran beteiligten Datentypen ändern. Bei diesem einfachen
Beispiel ist das kein großes Problem, aber wenn sich die ganzen Werte
über ein größeres Programm verteilen, kann es schwierig werden alle
Variablen zu finden und korrekt zu ändern.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">double</span> <span class="org-variable-name">start</span> = 23;
  <span class="org-type">double</span> <span class="org-variable-name">division</span> = start / 3;
  <span class="org-type">double</span> <span class="org-variable-name">addition</span> = division + 4;
  <span class="org-type">double</span> <span class="org-variable-name">ergebnis</span> = division * addition;
  cout &lt;&lt; <span class="org-string">"Ergebnis = "</span> &lt;&lt; ergebnis &lt;&lt; endl;
}
<span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Ergebnis = 89.4444</span>
</pre>
</div>
<p>
Wenn wir statt eines konkreten Typs <code>auto</code> verwenden, müssen wir nur
den Typ des Anfangswerts <code>start</code> ändern und alle anderen Typen
ändern sich automatisch mit.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-keyword">auto</span> <span class="org-variable-name">start</span> = 23;      <span class="org-comment-delimiter">// </span><span class="org-comment">start ist int</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">auto start = 23.0; // start ist double</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">division</span> = start / 3;
  <span class="org-keyword">auto</span> <span class="org-variable-name">addition</span> = division + 4;
  <span class="org-keyword">auto</span> <span class="org-variable-name">ergebnis</span> = division * addition;
  cout &lt;&lt; <span class="org-string">"Ergebnis = "</span> &lt;&lt; ergebnis &lt;&lt; endl;
}
<span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe bei start = 23:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Ergebnis = 77</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe bei start = 23.0:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Ergebnis = 89.4444</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> Strings</h3>
<div class="outline-text-3" id="text-4-6">
</div><div id="outline-container-sec-4-6-1" class="outline-4">
<h4 id="sec-4-6-1"><span class="section-number-4">4.6.1</span> Strings in C</h4>
<div class="outline-text-4" id="text-4-6-1">
<p>
In C sind Strings nichts anderes als Arrays vom Datentyp <code>char</code>. Jeder
Eintrag im Array entspricht also einem Zeichen. Das Ende des Strings
ist erreich, sobald ein Element des Arrays die Zahl <code>0</code> enthält.
(Achtung: Nicht das Zeichen ~'0'~). Dies bedeutet also, dass die Länge
des Arrays und die Länge des Strings nicht zwingend etwas miteinander
zu tun haben. Z.B. erzeugt der Befehl <code>char str[200] = "Hallo";</code> einen
String der Länge 5, welcher 6 Plätze des Arrays einnimmt (5 Zeichen
des Strings und die <code>0</code> für das Ende des Strings). Das Array selbst
ist aber 200 Elemente groß. Im Speicher sieht der String
folgendermaßen aus:
</p>
<table cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">Index</td>
<td class="left">0</td>
<td class="left">1</td>
<td class="left">2</td>
<td class="left">3</td>
<td class="left">4</td>
<td class="left">5</td>
<td class="left">6</td>
<td class="left">7</td>
<td class="left">8</td>
<td class="left">&#x2026;</td>
<td class="left">199</td>
</tr>

<tr>
<td class="left">Zeichen</td>
<td class="left"><code>H</code></td>
<td class="left"><code>a</code></td>
<td class="left"><code>l</code></td>
<td class="left"><code>l</code></td>
<td class="left"><code>o</code></td>
<td class="left"><code>\0</code></td>
<td class="left">undef</td>
<td class="left">undef</td>
<td class="left">undef</td>
<td class="left">&#x2026;</td>
<td class="left">undef</td>
</tr>

<tr>
<td class="left">Zahl</td>
<td class="left"><code>72</code></td>
<td class="left"><code>97</code></td>
<td class="left"><code>108</code></td>
<td class="left"><code>108</code></td>
<td class="left"><code>111</code></td>
<td class="left"><code>0</code></td>
<td class="left">undef</td>
<td class="left">undef</td>
<td class="left">undef</td>
<td class="left">&#x2026;</td>
<td class="left">undef</td>
</tr>
</tbody>
</table>

<p>
Die Art und Weise wie Strings in C implementiert sind hat einige Nachteile:
</p>
<ul class="org-ul">
<li>Wir müssen uns selbst darum kümmern, dass ein Array groß genug ist
um Platz für den String zu haben. Eine Ausnahme ist die Zuweisung
eines fixen Strings direkt bei der Initialisierung eines Strings
(z.B. ~char str[] = "Hallo"~). In diesem Fall kann der Compiler
selbst bestimmen wie groß der String sein muss.
</li>
<li>Falls wir das Array zu klein wählen, bekommen wir keine
Fehlermeldung. Das System schreibt einfach über das reservierte
Array hinaus und überschreibt möglicherweise wichtige
Speicherbereiche unseres Programms
</li>
<li>Falls aus irgend einem Grund die abschließende <code>0</code> des Strings
fehlt, so lesen alle Stringfunktionen (z.B. <code>printf("%s",str)</code>
einfach über das Stringende hinaus bis irgendwo im Speicher eine <code>0</code>
steht)
</li>
</ul>
<p>
Strings verhalten sich in C (weil es einfach Arrays sind) oft nicht so
wie man es erwarten würde. Ein Beispiel: Wir wollen z.B. zwei Strings
<code>str1</code> und <code>str2</code> aneinanderhängen und in einem String <code>str3</code>
speichern. In C sieht das folgendermaßen aus:
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string.h&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
</pre>
</div>
<p>
Wir müssen uns selbst darum kümmern, dass <code>str1</code>, <code>str2</code>, und <code>str3</code>
groß genug ist. Aus diesem Grund wählt man die Arrays häufig größer
als eigentlich notwendig.
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="org-type">char</span> <span class="org-variable-name">str1</span>[100], <span class="org-variable-name">str2</span>[100], <span class="org-variable-name">str3</span>[200];
</pre>
</div>
<p>
Nach der Initialisierung, können wir einem String in C nichts mehr mit
<code>=</code> zuweisen. <code>str1 = "Hello "~ funktioniert also nicht! Wir müssen
eine spezielle Funktion namens ~strcpy</code> (string copy) verwenden. Diese
Funktion überprüft nicht, ob das Array auch groß genug für den String
ist!
</p>
<div class="org-src-container">

<pre class="src src-C">strcpy(str1, <span class="org-string">"Hello "</span>);
strcpy(str2, <span class="org-string">"World"</span>);
</pre>
</div>
<p>
Man könnte meinen, dass man zwei Strings aneinanderhängt indem man
z.B. <code>str1 + str2</code> schreibt. Das ist in C aber nicht möglich. Um die
Strings aneinanderzuhängen müssen wir zuerst <code>str1</code> nach <code>str3</code>
kopieren.
</p>
<div class="org-src-container">

<pre class="src src-C">strcpy(str3, str1);
</pre>
</div>
<p>
Anschließend können wir die Funktion <code>strcat</code> (string concatenation)
verwenden um einen zusätzlichen String an <code>str3</code> anzuhängen. Auch hier
wird nicht überprüft ob <code>str3</code> groß genug ist um den ganzen String
aufzunehmen!
</p>
<div class="org-src-container">

<pre class="src src-C">  strcat(str3, str2);
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe von str3</span>
  printf(<span class="org-string">"%s"</span>, str3);
}
</pre>
</div>
<p>
Man sieht also, dass Strings in C relativ kompliziert sind.
</p>
</div>
</div>
<div id="outline-container-sec-4-6-2" class="outline-4">
<h4 id="sec-4-6-2"><span class="section-number-4">4.6.2</span> Strings in C++</h4>
<div class="outline-text-4" id="text-4-6-2">
<p>
In C++ gibt es einen eigenen Datentyp für Strings namens
<code>std::string</code>. Dieser verhält sich viel mehr wie ein normaler Datentyp
(<code>int</code>, <code>double</code>, &#x2026;). Um C++ Strings verwenden zu können müssen Sie
diese String Bibliothek mittels <code>#include &lt;string&gt;</code> einbinden. Das
letzte Beispiel sieht mit Verwendung von C++ Strings folgendermaßen
aus:
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">str1</span>, <span class="org-variable-name">str2</span>, <span class="org-variable-name">str3</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Platz f&#252;r beliebig viele Zeichen</span>
  str1 = <span class="org-string">"Hello "</span>;              <span class="org-comment-delimiter">// </span><span class="org-comment">Wir k&#246;nnen einfach mit "=" zuweisen</span>
  str2 = <span class="org-string">"World"</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">H&#228;nge str1 und str2 zusammen und speichere in str3</span>
  str3 = str1 + str2;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Gib str3 auf Bildschirm aus</span>
  <span class="org-constant">std</span>::cout &lt;&lt; str3;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-6-3" class="outline-4">
<h4 id="sec-4-6-3"><span class="section-number-4">4.6.3</span> Vergleich von C++Strings</h4>
<div class="outline-text-4" id="text-4-6-3">
<p>
In C++ können Strings einfach mittels <code>==</code> verglichen werden. (In C
funktioniert das nicht, hier muss die Funktion <code>strcmp</code> verwendet
werden und das Ergebnis auf <code>0</code> überprüft werden. Noch ungünstiger
ist, dass z.B. <code>str1 == str2</code> in C eine gültige Anweisung ist, aber
nicht die Strings vergleicht sondern die Adressen an denen <code>str1</code> und
<code>str2</code> liegen!). In C++ funktionieren auch die Vergleichsoperatoren
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, &#x2026; Sie testen die alphabetische Reihenfolge zweier
Strings.
</p>

<p>
In C:
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="org-keyword">if</span> (strcmp(str1, str2) == 0) {
  printf(<span class="org-string">"String 1 und 2 sind gleich"</span>);
}
</pre>
</div>

<p>
In C++:
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">if</span> (str1 == str2) {
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"String 1 und 2 sind gleich"</span>;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-6-4" class="outline-4">
<h4 id="sec-4-6-4"><span class="section-number-4">4.6.4</span> Umwandlung von C++String nach C-String</h4>
<div class="outline-text-4" id="text-4-6-4">
<p>
Falls wir aus irgend welchen Gründen einen klassischen C-String aus
einem C++ String erzeugen müssen (z.B. weil wir eine C-Bibliothek
verwenden wollen) erreichen wir das mittels <code>.c_str()</code>. Wollen wir
z.B. einen C-String aus <code>str3</code> erzeugen, schreiben wir <code>str3.c_str()</code>.
</p>
</div>
</div>
<div id="outline-container-sec-4-6-5" class="outline-4">
<h4 id="sec-4-6-5"><span class="section-number-4">4.6.5</span> Beispiel 1</h4>
<div class="outline-text-4" id="text-4-6-5">
<p>
Wir können C++ Strings wie ganz normale Variablen behandeln und Sie
problemlos als Parameter an eine Funktion schicken, oder sie als
Rückgabewert einer Funktion verwenden. 
</p>

<p>
Zum Beispiel: Eine Möglichkeit, <code>bool</code> mit <code>cout</code> als Text <code>true</code> und
<code>false</code> auszugeben ist es den Wert mit Hilfe einer Funktion von <code>bool</code>
nach <code>string</code> zu konvertieren und diesen String dann mittels <code>cout</code>
auszugeben.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Verhindert, dass wir &#252;berall std:: schreiben m&#252;ssen</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Nimmt einen bool Wert entgegen (true, false) und liefert je nach</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#252;bergebenem Wert des String "true" oder "false" zur&#252;ck</span>
<span class="org-type">string</span> <span class="org-function-name">bool_to_string</span>(<span class="org-type">bool</span> <span class="org-variable-name">b</span>) {
  <span class="org-keyword">if</span> (b == <span class="org-constant">true</span>)
    <span class="org-keyword">return</span> <span class="org-string">"true"</span>;
  <span class="org-keyword">else</span>
    <span class="org-keyword">return</span> <span class="org-string">"false"</span>;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">bool</span> <span class="org-variable-name">b1</span> = <span class="org-constant">false</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">b2</span> = <span class="org-constant">true</span>;

  cout &lt;&lt; <span class="org-string">"b1 = "</span> &lt;&lt; bool_to_string(b1) &lt;&lt; endl;
  cout &lt;&lt; <span class="org-string">"b2 = "</span> &lt;&lt; bool_to_string(b2) &lt;&lt; endl;
  cout &lt;&lt; <span class="org-string">"false = "</span> &lt;&lt; bool_to_string(<span class="org-constant">false</span>) &lt;&lt; endl;
  cout &lt;&lt; <span class="org-string">"true = "</span> &lt;&lt; bool_to_string(<span class="org-constant">true</span>) &lt;&lt; endl;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">b1 = false</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">b2 = true</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">false = false</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">true = true</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-6-6" class="outline-4">
<h4 id="sec-4-6-6"><span class="section-number-4">4.6.6</span> Beispiel 2</h4>
<div class="outline-text-4" id="text-4-6-6">
<p>
Da wir Strings sehr einfach auf Gleichheit überprüfen können und auch
einfach als Parameter einer Funktion übernehmen können, ist es auch
sehr einfach die Strings ~"true"~ und ~"false"~ wieder in einen <code>bool</code>
Wert zu konvertieren.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Verhindert, dass wir &#252;berall std:: schreiben m&#252;ssen</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Nimmt einen String entgegen ("true", "false") und liefert je nach</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#252;bergebenem String die bool werte true oder false zur&#252;ck</span>
<span class="org-type">bool</span> <span class="org-function-name">string_to_bool</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
  <span class="org-keyword">if</span> (s == <span class="org-string">"true"</span>)
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  <span class="org-keyword">else</span>
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">string</span> <span class="org-variable-name">s1</span> = <span class="org-string">"false"</span>;
  <span class="org-type">string</span> <span class="org-variable-name">s2</span> = <span class="org-string">"true"</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Konvertieren der Strings nach bool</span>
  <span class="org-type">bool</span> <span class="org-variable-name">b1</span> = string_to_bool(s1);
  <span class="org-type">bool</span> <span class="org-variable-name">b2</span> = string_to_bool(s2);

  cout &lt;&lt; <span class="org-string">"b1 = "</span> &lt;&lt; b1 &lt;&lt; endl;
  cout &lt;&lt; <span class="org-string">"b2 = "</span> &lt;&lt; b2 &lt;&lt; endl;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Das ganze geht nat&#252;rlich auch ohne zus&#228;tzliche Variable</span>
  cout &lt;&lt; <span class="org-string">"false = "</span> &lt;&lt; string_to_bool(<span class="org-string">"false"</span>) &lt;&lt; endl;
  cout &lt;&lt; <span class="org-string">"true = "</span> &lt;&lt; string_to_bool(<span class="org-string">"true"</span>) &lt;&lt; endl;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">b1 = 0</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">b2 = 1</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">false = 0</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">true = 1</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Ein-/Ausgabe</h2>
<div class="outline-text-2" id="text-5">
<p>
Um die folgende Funktionalität für die Ein- und Ausgabe verwenden zu
können muss die Headerdatei <code>iostream</code> mittels <code>#include &lt;iostream&gt;</code>
eingebunden werden.
</p>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Ausgabe</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Zur Ausgabe von Daten auf dem Bildschirm wird in C++ üblicherweise
<code>std::cout</code> (für character out) verwendet. Variablen, Konstanten,
Ausdrücke, etc. werden mittels <code>&lt;&lt;</code> nach <code>std::cout</code> geschickt. Das
System erkennt automatisch den Typ der Daten die ausgegeben werden
sollen und verwendet die korrekte Formatierung (man kann sich also die
Formatplatzhalter von <code>printf</code> wie z.B. <code>%d</code>, <code>%f</code>, <code>%s</code>, etc. sparen)
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Variablen</span>
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = 23;
  <span class="org-type">double</span> <span class="org-variable-name">d</span> = 42.47;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">s</span> = <span class="org-string">"Hello World!"</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; i;
  <span class="org-constant">std</span>::cout &lt;&lt; d;
  <span class="org-constant">std</span>::cout &lt;&lt; s;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Konstanten</span>
  <span class="org-constant">std</span>::cout &lt;&lt; 45;
  <span class="org-constant">std</span>::cout &lt;&lt; 34.5;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Noch ein Hello!"</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ausdr&#252;cke</span>
  <span class="org-constant">std</span>::cout &lt;&lt; 2 * i;
  <span class="org-constant">std</span>::cout &lt;&lt; (i * d) / 3.4;
  <span class="org-constant">std</span>::cout &lt;&lt; s + <span class="org-string">" World2!"</span>;
}
<span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">2342.47Hello World!4534.5Noch ein Hello!46287.297Hello World! World2!</span>
</pre>
</div>

<p>
Die gleichzeitige Ausgabe mehrerer Daten kann durch wiederholtes
aneinanderhängen von <code>&lt;&lt;</code> erzielt werden. Will man z.B. die Variablen
<code>a</code>, <code>b</code> und <code>c</code> ausgeben, dann schreibt man <code>std::cout &lt;&lt; a &lt;&lt; b &lt;&lt;
c;</code>.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = 23;
  <span class="org-type">double</span> <span class="org-variable-name">d</span> = 42.47;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">s</span> = <span class="org-string">"Hello World!"</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Variablen</span>
  <span class="org-constant">std</span>::cout &lt;&lt; i &lt;&lt; d &lt;&lt; s;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Konstanten</span>
  <span class="org-constant">std</span>::cout &lt;&lt; 45 &lt;&lt; 34.5 &lt;&lt; <span class="org-string">"Noch ein Hello!"</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ausdr&#252;cke</span>
  <span class="org-constant">std</span>::cout &lt;&lt; 2 * i &lt;&lt; (i * d) / 3.4 &lt;&lt; s + <span class="org-string">" World2!"</span>;
}
<span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">2342.47Hello World!4534.5Noch ein Hello!46287.297Hello World! World2!</span>
</pre>
</div>

<p>
Es werden bei Ausgabe mehrerer Daten in einer Zeile keine
automatischen Leerzeichen eingefügt. Falls man Leerzeichen hab will,
müssen diese manuell zwischen den Daten ausgegeben werden.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = 23;
  <span class="org-type">double</span> <span class="org-variable-name">d</span> = 42.47;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">s</span> = <span class="org-string">"Hello World!"</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Variablen</span>
  <span class="org-constant">std</span>::cout &lt;&lt; i &lt;&lt; <span class="org-string">" "</span> &lt;&lt; d &lt;&lt; <span class="org-string">" "</span> &lt;&lt; s;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Konstanten</span>
  <span class="org-constant">std</span>::cout &lt;&lt; 45 &lt;&lt; <span class="org-string">" "</span> &lt;&lt; 34.5 &lt;&lt; <span class="org-string">" "</span> &lt;&lt; <span class="org-string">"Noch ein Hello!"</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ausdr&#252;cke</span>
  <span class="org-constant">std</span>::cout &lt;&lt; 2 * i &lt;&lt; <span class="org-string">" "</span> &lt;&lt; (i * d) / 3.4 &lt;&lt; <span class="org-string">" "</span> &lt;&lt; s + <span class="org-string">" World2!"</span>;
}
<span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">23 42.47 Hello World!45 34.5 Noch ein Hello!46 287.297 Hello World! World2!</span>
</pre>
</div>

<p>
An vorherigen Beispielen sieht man, dass <code>cout</code>, genauso wie auch
<code>printf</code>, keinen automatischen Zeilenumbruch einfügt. Um einen
Zeilenumbruch zu erzwingen gibt man entweder <code>std::endl</code> (für endline)
oder wie in C ein <code>\n</code> aus.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = 23;
  <span class="org-type">double</span> <span class="org-variable-name">d</span> = 42.47;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">s</span> = <span class="org-string">"Hello World!"</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Variablen</span>
  <span class="org-constant">std</span>::cout &lt;&lt; i &lt;&lt; <span class="org-string">" "</span> &lt;&lt; d &lt;&lt; <span class="org-string">" "</span> &lt;&lt; s &lt;&lt; <span class="org-string">"\n"</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Konstanten</span>
  <span class="org-constant">std</span>::cout &lt;&lt; 45 &lt;&lt; <span class="org-string">" "</span> &lt;&lt; 34.5 &lt;&lt; <span class="org-string">" "</span> &lt;&lt; <span class="org-string">"Noch ein Hello!"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ausdr&#252;cke</span>
  <span class="org-constant">std</span>::cout &lt;&lt; 2 * i &lt;&lt; <span class="org-string">" "</span> &lt;&lt; (i * d) / 3.4 &lt;&lt; <span class="org-string">" "</span> &lt;&lt; s + <span class="org-string">" World2!\n"</span>;
}
<span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">23 42.47 Hello World!</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">45 34.5 Noch ein Hello!</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">46 287.297 Hello World! World2!</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Eingabe</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Analog zur Ausgabe von Daten mittels <code>std::cout</code> werden mittels
<code>std::cin</code> (character in) Daten vom Benutzer eingelesen. Um Daten
einlesen zu können muss bereits eine Variable deklariert sein in
welche die Daten geschrieben werden können. Das eigentliche Einlesen
geschieht mit dem Befehl <code>std::cin &gt;&gt; variablenname;</code>. Beachten Sie,
dass die "Pfeile" von <code>cin</code> in die entgegengesetze Richtung weisen wie
bei <code>cout</code>: <code>std::cin &gt;&gt; bla;</code> vs <code>std::cout &lt;&lt; bla;</code>.
</p>

<p>
Wir lesen z.B. einen Integer ein und geben ihn wieder aus:
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ausgabe der Eingabeaufforderung</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Bitte geben Sie einen Integer ein: "</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Deklarieren der Variable in der die Eingabe gespeichert wird</span>
  <span class="org-type">int</span> <span class="org-variable-name">i</span> = 0;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Einlesen vom Benutzer in die Variable</span>
  <span class="org-constant">std</span>::cin &gt;&gt; i;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Zu diesem Zeitpunkt ist die Variable i mit dem Wert bef&#252;llt, den</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">der Benutzer eingegeben hat und wir k&#246;nnen den Inhalt ausgeben</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Sie haben die Zahl "</span> &lt;&lt; i &lt;&lt; <span class="org-string">" eingegeben!\n"</span>;
}
</pre>
</div>
<p>
<code>cin</code> liest immer bis zum nächsten Leerzeichen und man kann auch hier
mehrere Daten gleichzeitig einlesen indem mehrere Variablen mittels
<code>&gt;&gt;</code> aneinanderhängt werden. 
</p>

<p>
Wir lesen z.B. drei <code>double</code> Werte ein und geben die Summe dieser aus:
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">double</span> <span class="org-variable-name">a</span> = 0, <span class="org-variable-name">b</span> = 0, <span class="org-variable-name">c</span> = 0;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Bitte geben Sie drei Zahlen ein: "</span>;
  <span class="org-constant">std</span>::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Die Summe der eingegebenen Zahlen = "</span> &lt;&lt; a + b + c &lt;&lt; <span class="org-constant">std</span>::endl;
}
</pre>
</div>
<p>
Bei der Aufforderung <code>Bitte geben Sie drei Zahlen ein:</code> kann nun z.B.
<code>2.25 13.2 5.25</code> eingegeben werden und die Variablen werden der Reihe
nach befüllt: <code>a = 2.25</code>, <code>b = 13.2</code> und <code>c = 5.25</code>.
</p>
</div>
<div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1"><span class="section-number-4">5.2.1</span> <code>getline</code></h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
Wie erwähnt, liest <code>cin</code> jeweils bis zum nächsten Leerzeichen.
Insbesondere für das Einlesen eines Strings kann das unpraktisch sein,
weil man mit <code>std::cin</code> dadurch nur ein einziges Wort einlesen kann.
Um längere Texte einlesen zu können gibt es einen speziellen Befehl
namens <code>std::getline</code> welcher alles bis zum nächsten Zeilenumbruch
einliest und in einer Stringvariable abspeichert.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Sebastian Stabinger</p>
<p class="email">Email: <a href="mailto:sebastian@stabinger.name">sebastian@stabinger.name</a></p>
<p class="date">Created: 2018-03-21 Wed 00:05</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
